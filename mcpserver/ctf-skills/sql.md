## SQL 注入 (SQL Injection) 手法

### 1. 认证绕过/逻辑判断注入 (Authentication Bypass)

这类攻击旨在通过注入永真条件来绕过登录验证，使其返回管理员或其他高权限用户的信息。

| 手法/技巧 | 目的和 Payload 示例 | 来源支持 |
| :--- | :--- | :--- |
| **标准永真条件 + 注释** | 在用户名或密码字段中插入永真条件，通常使用单引号闭合原语句，然后使用 `-- -` 或 `#` (URL 编码为 `%23` 或 `%20--%20-`) 忽略掉查询的其余部分。 | `username=' OR 1=1-- -` |
| **永真字符串匹配** | 使用 `' OR '1'='1` 确保条件为真。 | `username=admin' OR '1'='1' -- -` |
| **利用通配符绕过** | 尝试使用 `%` 通配符匹配任何密码（例如，如果应用使用 `LIKE` 进行匹配）。 | `password=%` |
| **非标准逻辑符** | 尝试使用 `OR` 的替代写法，例如双竖线 `||` 或模糊匹配。 | `username=' || '1'='1` |

### 2. 基于联合查询的数据提取 (UNION-Based Data Extraction)

此方法适用于页面直接显示查询结果的场景，通过合并恶意查询来获取数据库信息。

| 步骤/技巧 | 目的和 Payload 示例 |
| :--- | :--- |
| **探测字段数 (ORDER BY)** | 通过递增 `ORDER BY N` 语句来确定查询结果的列数。 | 
| **确定可用列** | 使用 `UNION SELECT NULL, NULL, ...` 找到可以回显数据的列的位置。 | 
| **提取信息** | 在可回显的列位置注入 `SELECT` 语句以获取敏感数据。 |
| **执行数据库函数** | 尝试注入数据库函数来获取哈希值或其他计算结果。 | 
| **读取文件 (LOAD_FILE)** | 利用数据库特性（如 MySQL）尝试读取系统文件。 | 
### 3. 基于错误的注入 (Error-Based SQLi)

当页面不直接回显数据但会抛出数据库错误时，攻击者强制数据库将敏感数据包含在错误信息中。

| 手法/技巧 | 目的和 Payload 示例 (以 MySQL `updatexml` 为例) | 
| :--- | :--- | 
| **获取数据库名称** | 构造畸形的 `updatexml` 函数，利用 `concat(0x7e,(SELECT database()),0x7e)` 将数据库名注入路径中，触发 XML 解析错误。 | 
| **枚举表名** | 通过 `information_schema.tables` 提取当前数据库的所有表名。 | 
| **枚举列名和数据** | 针对特定表名（如 `admins` 或 `flag`）提取列名和数据。 | 
| **提取 Flag 值** | 针对包含 flag 的表进行数据提取。 |
| **辅助长度探测** | 辅助盲注或数据提取过程，确定目标数据的长度。 | 

### 4. 基于时间的盲注 (Time-Based Blind SQLi)

用于应用不返回数据也不报错的**完全盲注**场景，通过观察响应时间来推断数据库操作的逻辑真假。

| 手法/技巧 | 目的和 Payload 示例 |
| :--- | :--- | 
| **简单延迟探测** | 注入 `SLEEP(N)` 函数，观察页面响应是否延迟 N 秒。 | 
| **条件延迟探测** | 使用 `IF` 语句结合 `SLEEP`，如果条件成立（例如数据首字母匹配正确）则延迟，否则不延迟。 |

### 5. 堆叠查询注入 (Stacked Queries)

当应用允许使用分号 `;` 分隔多条 SQL 语句时，可以执行数据修改或删除操作。

| 手法/技巧 | 目的和 Payload 示例 | 
| :--- | :--- | 
| **更新管理员密码** | 注入一条 `UPDATE` 语句来修改用户密码（假设密码是明文或已知哈希算法）。 | 
| **利用 Tab 符绕过/混淆** | 尝试在 SQL 语句中使用 TAB 字符 (`\t` 或 `%09`) 来绕过简单的黑名单过滤或混淆检测。 | 

### 6. 应用层认证绕过 (非 SQL 注入但达成类似目标)

\达到了认证绕过或权限提升目的的**应用层数据注入**手法，通常针对 PHP 或其他语言的松散类型和反序列化漏洞。

| 攻击类型 | 手法/技巧 | 
| :--- | :--- |
| **PHP 类型混淆/数据类型注入** | 针对 PHP 松散类型比较的特性，尝试将字符串类型的密码与布尔值或浮点数进行比较，实现认证绕过。 | 
| **PHP 反序列化攻击 (PHAR/Cookie)** | 构造包含管理员用户信息的 PHP 序列化对象，并将其 Base64 编码后注入到 `Cookie` 中（例如 `creds` 参数），从而绕过认证。 | 
| **GraphQL/NoSQL 注入** | 在非关系型数据库或 GraphQL 查询中，注入类似 SQLi 的逻辑条件来绕过权限或扩大查询范围。 |

其中，**基于错误的注入**（使用 `updatexml` 等函数）和**认证绕过**（`OR 1=1`）是最常见的攻击模式。

#### 绕过技巧

过滤规则：
- 空格（`\s`）
- 关键词：`and`, `null`, `where`, `limit`, `like`, `substring`, `substr`


| 过滤内容 | 绕过方法 |
|---------|---------|
| 空格 | 使用 `/**/` 或 `()` |
| AND | 使用 `&&` |
| OR | 未过滤，可直接使用 |
| SUBSTRING/SUBSTR | 使用 `MID()`, `LEFT()`, `RIGHT()` |
| 大小写敏感比较 | 使用 `BINARY()` 函数 |
